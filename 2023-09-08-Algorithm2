---
layout: post
title:  "선택 정렬"
---

##배열과 리스트의 빅오표기
배열 읽기 : O(1) , 배열 삽입 : O(n), 배열 삭제 : O(n)
리스트 읽기 : O(n), 리스트 삽입 : O(1), 리스트 삭제 : O(1)
(지우고자 하는 원소에 바로 접근할 수 있을 때만 삽입과 삭제가 O(1) 시간이 된다는 점이 중요)

##삽입하기
원소를 배열이나 리스트의 중앙에 삽입한다면 배열과 리스트 중 어느 것이 나을까?
리스트는 이전 원소가 무엇을 가리키는지 바꾸기만 하면 된다.

브런치 먹기 -> 보체 하기 -> 차 마시기
브런치 먹기 -> 보체 하기 -> 차 사기 -> 차 마시기

하지만, 배열에서는 다음에 오는 모든 원소의 위치를 바꾸어야 한다.
(메모리에 남아 있는 공간이 없어서 실패할 수도 있다.)

브런치 먹기, 보체 하기, 차 마시기
브런치 먹기, 보체 하기, 차 사기, 차 마시기(이 일은 뒤로 밀어내야 한다.)

##삭제하기
이 경우에도 이전 원소가 가리키는 위치만 바꾸면 되기 때문에 리스트가 더 낫다.
배열에서는 원소 하나만 삭제하고 싶을 때도 모든 것을 다 옮겨야 한다.
경우에 따라 다르지만 배열에서는 임의의 원소에 접근하는 것이 가능하기 때문에 배열을 쓰는 경우가 더 많다.

##접근방식
순차 접근은 원소를 첫 번째부터 하나씩 읽는 것을 뜻합니다.
연결 리스트는 순차 접근밖에 할 수 없다. 만약 연결 리스트에 있는 10번째 원소를 읽으려면 그 앞의
9개 원소를 모두 읽어서 10번째 원소로 가는 링크를 찾아내야 한다.
반면에 임의 접근은 10번째 원소로 바로 건너뛸 수 있다.
임의 접근을 필요로 하면 배열을 사용한다.


#선택 정렬
플레이 리스트에 가수별로 몇 곡을 들었는지 기록되어 있다고하자.
a : 130
b : 110
c : 32
d : 45
e : 67
f : 53
g : 92
이 목록을 가장 많이 들은 것부터 가장 적게 들은 것 순서로 정렬하라
=> 모든 항목을 살펴보고 가장 많이 연주된 가수를 찾아 새로운 리스트에 기록한다.
위의 행위는 O(n)의 시간이 걸린다. 이 행위를 리스트 수만큼 반복 (n)
즉, O(n * n)이 걸린다.
더 정확하게는 처음에는 n번 그 다음에는 n-1번, n-2번....로 줄어들겠지만 빅오 표기법에서는 상수항을 무시한다.

##요약
연결 리스트는 삽입과 삭제에 좋고, 배열은 임의 접근에 좋다.

