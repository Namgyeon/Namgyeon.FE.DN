---
layout: post
title:  "해시 테이블"
---

## 해시 함수
해시 함수는 문자열을 받아서 숫자를 반환하는 함수이다.
"NAMASTE" => 7
"HOLA" => 4

"HELLO" => 2 (해시 함수)

• 해시 함수에는 일관성이 있어야 한다. 예를 들어 만약 "apple"을 넣었을 때 "4"를 반환한다면 
"apple"을 넣을 때마다 반환되는 값은 항상 "4"이어야 한다.
• 다른 단어가 들어가면 다른 숫자가 나와야 한다. 예를 들어, 어떤 단어를 넣어도 "1"만 나온다면
좋은 해시 함수가 아니다. 가장 좋은 경우는 서로 다른 단어에 대해 모두 서로 다른 숫자가 나와야 한다.

빈 배열이 있다고 하자. 나는 모든 가격을 이 배열에 저장할 것이다.
해시 함수에 "apple"을 넣는다 "apple" => 3 해시함수는 "3"을 출력한다.
즉 "apple"의 가격은 배열의 3번 인덱스 위치에 저장되는 것이다.
"milk" => 0
"banana" => 2
등등 전체 배열이 가격으로 채워질 것이다.
이제 내가 "avocado의 가격이 얼마지?" 라고 물어본다면 배열을 탐색할 필요 없이 그냥
해시 함수에 avocado를 넣으면 된다. 그럼 해시 함수는 가격이 저장된 인덱스를 알려준다.

• 해시 함수는 배열이 얼마나 큰지 알고 있어야 한다. 왜냐하면 배열이 5개의 원소만 가질 수 있는데
10을 반환해서는 안되기 때문이다.

(어떠한 프로그램을 만들게 될 때, 무슨 알고리즘이 적합한지, 그 알고리즘이 효율적인지 생각하고 만든다.)

캐싱 : 행성에 대해 계속 물어보는 어린 조카가 있다고 생각하자. "화성은 지구에서 얼마나 떨어져 있어?", "달은 얼마나 떨어져 있어?"
나는 달이 384,000km 떨어져 있다는 것을 외우게 되었다. 답을 알고 있으니 조카에게 굳이 검색을 하지 않아도
대답을 할 수 있게 되었다. 이렇게 정보를 다시 계산하지 않고 저장했다가 알려주는 것이 캐싱이다.

## 충돌
두 개의 키가 같은 공간에 할당되는 것이다. 에를 들어 알파벳26개의 순서대로 넣을 수 있는 배열이 있다고 하자.
첫번째는 a, 두번째는 b.....마지막(26번쨰)은 z.
첫번째에 apple을 할당하고 두번쨰는 banana....를 할당한다.
만약 avocado를 해시에 넣고 싶으면 첫번째 공간에 다시 할당해야한다. 하지만 이곳에는 이미 apple이 할당 되어있다.
이런 것을 충돌이라 한다. avocado를 넣게 되면 apple을 덮어쓰게 된다. 그러면 다음 번에 누군가 apple을 찾을때
대신 avocado가 나오게 된다.  충돌은 나쁜 현상이기 때문에 해결해야 한다.

가장 간단한 방법은 같은 공간에 여러 개의 키를 연결 리스트로 만들어 넣는 것이다.
-단점 : 연결 리스트가 길어지면 해시 테이블의 속도도 느려진다.

충돌을 피하려며 다음 두 가지가 필요하다.
• 낮은 사용률 == 해시 테이블에 있는 공간의 수 / 해시 테이블에 있는 항목의 수  => 충돌이 적게 일어남. (보통 사용률이 0.7보다 커지면 리사이징한다.)
• 좋은 해시 함수
